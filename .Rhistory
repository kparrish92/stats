datamatrix <- matrix(0,nrow=nsubjs,ncol=nsamples)
for (s in 1:nsubjs){datamatrix[s,] <- rnorm(nsamples,mean=rnorm(1,mean=groupmean,sd=interpSD),sd=intrapSD)}
subjmeans <- rowMeans(datamatrix)
subjSEs <- apply(datamatrix,1,sd)/sqrt(nsamples)
if(outputplot==1){pdf("hist3.pdf", bg="transparent", height = 5.5, width = 5.5)}
if(outputplot==2){postscript("hist3.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)}
plotlims <- c(-12,12,0,1.1)  # define the x and y limits of the plot (minx,maxx,miny,maxy)
ticklocsx <- seq(-12,12,4)    # locations of tick marks on x axis
ticklocsy <- (0:5)/5    # locations of tick marks on y axis
ticklabelsx <- ticklocsx        # set labels for x ticks
ticklabelsy <- c("0","0.2","0.4","0.6","0.8","1")    # set labels for y ticks
par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
xvals <- seq(-12,12,0.1)
sampleSD <- sqrt(interpSD^2 + (intrapSD^2)/nsamples)
gausfunc <- exp(-((xvals-0)^2)/(2*sampleSD^2))
for (s in 1:nsubjs){
ypos <- runif(1,min=0,max=0.95*exp(-((subjmeans[s])^2)/(2*sampleSD^2)))
polygon(c(subjmeans[s]-subjSEs[s],subjmeans[s]+subjSEs[s],subjmeans[s]+subjSEs[s],subjmeans[s]-subjSEs[s]),c(ypos-0.005,ypos-0.005,ypos+0.005,ypos+0.005),col=rgb(1,1,1),border=NA)
points(subjmeans[s], ypos, pch = 16, col=rgb(1,0.5,0.5), cex=0.6, lwd=3)   # draw the data points themselves
}
lines(xvals, gausfunc, col=rgb(1,0.5,0.5),lty=1,lwd=5) # plot upside down hanging from the top axis with our transparent colour
lines(c(0,0),c(0,1), col='grey', lwd=3, cex=0.5, lty=1)     # draw a line connecting the points
if(outputplot>0){dev.off()}  # this line goes after you've finished plotting (to output the example below, move it to the bottom of the script)
# if we're outputting as postscript, it's because we're merging to create the full figure
if(outputplot==2){
library(grImport)
PostScriptTrace('hist1.ps')
e1 <- readPicture('hist1.ps.xml')
PostScriptTrace('hist2.ps')
e2 <- readPicture('hist2.ps.xml')
for (n in 1:length(e2@paths)){
temp <- class(e2@paths[n]$path)[1]
if (pmatch(temp,"PictureFill",nomatch=0)){
if (sum(col2rgb(e2@paths[n]$path@rgb))==765){e2@paths[n]$path@rgb <- rgb(1,0.5,0,alpha=0.3)}}}
PostScriptTrace('hist3.ps')
e3 <- readPicture('hist3.ps.xml')
for (n in 1:length(e3@paths)){
temp <- class(e3@paths[n]$path)[1]
if (pmatch(temp,"PictureFill",nomatch=0)){
if (sum(col2rgb(e3@paths[n]$path@rgb))==765){e3@paths[n]$path@rgb <- rgb(1,0.5,0.5,alpha=0.3)}}}
PostScriptTrace('powercurves.ps')
e4 <- readPicture('powercurves.ps.xml')
PostScriptTrace('SDS.ps')
e5 <- readPicture('SDS.ps.xml')
PostScriptTrace('powervstrials.ps')
e6 <- readPicture('powervstrials.ps.xml')
PostScriptTrace('Meancontour1.ps')
e7 <- readPicture('Meancontour1.ps.xml')
for (n in 1:length(e7@paths)){
temp <- class(e7@paths[n]$path)[1]
if (pmatch(temp,"PictureFill",nomatch=0)){
if (sum(col2rgb(e7@paths[n]$path@rgb))<765){e7@paths[n]$path@rgb <- addalpha(e7@paths[n]$path@rgb,alpha=0.2)}}}
PostScriptTrace('Meancontour2.ps')
e8 <- readPicture('Meancontour2.ps.xml')
for (n in 1:length(e8@paths)){
temp <- class(e8@paths[n]$path)[1]
if (pmatch(temp,"PictureFill",nomatch=0)){
e8@paths[n]$path@rgb <- addalpha(e8@paths[n]$path@rgb,alpha=0.2)}}
pdf("Figure1.pdf", bg="transparent", height = 18, width = 16.5)
par(mar=c(0.1,0.1,0.1,0.1))
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(0,1), ylim=c(0,1))   # create an empty axis of the correct dimensions
grid.picture(e1,x=0.2,y=0.85,width=0.3,height=1)
grid.picture(e2,x=0.5,y=0.85,width=0.3,height=1)
grid.picture(e3,x=0.8,y=0.85,width=0.3,height=1)
grid.picture(e4,x=0.2,y=0.56,width=0.3,height=1)
grid.picture(e5,x=0.5,y=0.56,width=0.3,height=1)
grid.picture(e6,x=0.8,y=0.56,width=0.3,height=1)
grid.picture(e7,x=0.25,y=0.2,width=0.45,height=1)
grid.picture(e8,x=0.75,y=0.2,width=0.45,height=1)
text(-0.01,1,'(a)',pos=4,cex=3)
text(0.32,1,'(b)',pos=4,cex=3)
text(0.64,1,'(c)',pos=4,cex=3)
text(-0.01,0.72,'(d)',pos=4,cex=3)
text(0.32,0.72,'(e)',pos=4,cex=3)
text(0.65,0.72,'(f)',pos=4,cex=3)
text(-0.01,0.4,'(g)',pos=4,cex=3)
text(0.5,0.4,'(h)',pos=4,cex=3)
text(0.02,0.97,expression(paste(sigma[w], " = 0")),pos=4,cex=2)
text(0.02,0.94,expression(paste(sigma[b], " = 2")),pos=4,cex=2)
text(0.02,0.91,expression(paste(sigma[s], " = 2")),pos=4,cex=2)
text(0.02,0.88,expression(paste("1:",infinity, " trials")),pos=4,cex=2)
text(0.35,0.97,expression(paste(sigma[w], " = 10")),pos=4,cex=2)
text(0.35,0.94,expression(paste(sigma[b], " = 2")),pos=4,cex=2)
text(0.35,0.91,expression(paste(sigma[s], " = 3")),pos=4,cex=2)
text(0.35,0.88,"20 trials",pos=4,cex=2)
text(0.67,0.97,expression(paste(sigma[w], " = 10")),pos=4,cex=2)
text(0.67,0.94,expression(paste(sigma[b], " = 2")),pos=4,cex=2)
text(0.67,0.91,expression(paste(sigma[s], " = 2.1")),pos=4,cex=2)
text(0.67,0.88,"200 trials",pos=4,cex=2)
text(0.18,0.39,expression(paste(sigma[w], " = 0, ", sigma[b], " = 2")),pos=4,cex=2)
text(0.72,0.39,expression(paste(sigma[w], " = 10, ", sigma[b], " = 2")),pos=4,cex=2)
text(0.41,0.68,expression(paste(sigma[b], " = 2")),pos=4,cex=2)
text(0.88,0.52,"M=0.5",pos=4,cex=2)
text(0.88,0.49,"N=200",pos=4,cex=2)
dev.off()
file.remove(c('hist1.ps','hist2.ps','hist3.ps','powercurves.ps','SDs.ps','Meancontour1.ps','Meancontour2.ps','powervstrials.ps'))
file.remove(c('capturehist1.ps','capturehist2.ps','capturehist3.ps','capturepowercurves.ps','captureSDs.ps','captureMeancontour1.ps','captureMeancontour2.ps','capturepowervstrials.ps'))
file.remove(c('hist1.ps.xml','hist2.ps.xml','hist3.ps.xml','powercurves.ps.xml','SDs.ps.xml','Meancontour1.ps.xml','Meancontour2.ps.xml','powervstrials.ps.xml'))
}
toc()
PostScriptTrace('hist1.ps')
PostScriptTrace('hist1.ps')
?PostScriptTrace
library(grImport)
PostScriptTrace('hist1.ps')
PostScriptTrace('hist1.ps')
outputplot <- 2
library(pwr)
library(tictoc)
library(plyr)
addalpha <- function(col, alpha=1){apply(sapply(col, col2rgb)/255, 2, function(x) rgb(x[1], x[2], x[3], alpha=alpha))}
tic()
ramp <- colorRamp(c("black","darkblue","cornflowerblue"))  # create a ramp from one colour to another
groupmean <- 1
alphalevel <- 0.05
nsamplevect <<- seq(2,100,2)
nsubjs <<- seq(2,200,2)
intrapSD <- 0
interpSD <- 2
powerlist <- matrix(0,nrow=length(nsubjs),ncol=length(nsamplevect))
for (smp in 1:length(nsamplevect)){
for (s in 1:length(nsubjs)){
sampleSD <- sqrt(interpSD^2 + (intrapSD^2)/nsamplevect[smp])
destimate <- groupmean/sampleSD
output <- pwr.t.test(d=destimate,n=nsubjs[s],sig.level=alphalevel,type="one.sample",alternative='two.sided')
powerlist[s,smp] <- output$power
}}
powerlist <- round(powerlist*1000)/1000
if(outputplot==1){pdf("Meancontour1.pdf", bg="transparent", height = 5.5, width = 5.5)}
if(outputplot==2){postscript("Meancontour1.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)}
plotlims <- c(0,200,0,100)  # define the x and y limits of the plot (minx,maxx,miny,maxy)
ticklocsx <- seq(0,200,50)    # locations of tick marks on x axis
ticklocsy <- seq(0,100,25)    # locations of tick marks on y axis
ticklabelsx <- ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks
par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  # the 'line' command moves away from the axis, the 'las' command rotates to vertical
title(xlab="Sample size (N)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Trials per participant (k)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
colmatrix <- rgb(ramp(seq(0, 1, length = 101)), max = 255)
if(outputplot<2){for (n in 1:length(colmatrix)){colmatrix[n] <- addalpha(colmatrix[n],alpha=0.5)}}
.filled.contour(nsubjs,nsamplevect,powerlist,levels=seq(0,1,0.01),col=colmatrix)
cl <- contourLines(nsubjs,nsamplevect,powerlist,levels=seq(0.1,1,0.1))
colvect <- rgb(ramp(seq(0, 1, length = 10)), max = 255)
for (n in 1:length(cl)){
temp <- cl[n]
lines(temp[[1]]$x,temp[[1]]$y,col=colvect[temp[[1]]$level*10],lwd=3)
if (temp[[1]]$level==0.8){lines(temp[[1]]$x,temp[[1]]$y,col=colvect[temp[[1]]$level*10],lwd=9)}
}
legend(130, 97, c("10%","20%","30%","40%","50%","60%","70%","80%","90%","100%"), bg='white',cex=1, col=colvect, lty=1, lwd=c(3,3,3,3,3,3,3,9,3,3), box.lwd=2)
if(outputplot>0){dev.off()}  # this line goes after you've finished plotting (to output the example below, move it to the bottom of the script)
intrapSD <- 10
interpSD <- 2
powerlist <- matrix(0,nrow=length(nsubjs),ncol=length(nsamplevect))
for (smp in 1:length(nsamplevect)){
for (s in 1:length(nsubjs)){
sampleSD <- sqrt(interpSD^2 + (intrapSD^2)/nsamplevect[smp])
destimate <- groupmean/sampleSD
output <- pwr.t.test(d=destimate,n=nsubjs[s],sig.level=alphalevel,type="one.sample",alternative='two.sided')
powerlist[s,smp] <- output$power
}}
powerlist <- round(powerlist*1000)/1000
if(outputplot==1){pdf("Meancontour2.pdf", bg="transparent", height = 5.5, width = 5.5)}
if(outputplot==2){postscript("Meancontour2.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)}
plotlims <- c(0,200,0,100)  # define the x and y limits of the plot (minx,maxx,miny,maxy)
ticklocsx <- seq(0,200,50)    # locations of tick marks on x axis
ticklocsy <- seq(0,100,25)    # locations of tick marks on y axis
ticklabelsx <- ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks
par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  # the 'line' command moves away from the axis, the 'las' command rotates to vertical
title(xlab="Sample size (N)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Trials per participant (k)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
colmatrix <- rgb(ramp(seq(0, 1, length = 101)), max = 255)
if(outputplot<2){for (n in 1:length(colmatrix)){colmatrix[n] <- addalpha(colmatrix[n],alpha=0.5)}}
.filled.contour(nsubjs,nsamplevect,powerlist,levels=seq(0,1,0.01),col=colmatrix)
cl <- contourLines(nsubjs,nsamplevect,powerlist,levels=seq(0.1,1,0.1))
colvect <- rgb(ramp(seq(0, 1, length = 10)), max = 255)
for (n in 1:length(cl)){
temp <- cl[n]
lines(temp[[1]]$x,temp[[1]]$y,col=colvect[temp[[1]]$level*10],lwd=3)
if (temp[[1]]$level==0.8){lines(temp[[1]]$x,temp[[1]]$y,col=colvect[temp[[1]]$level*10],lwd=9)}
}
if(outputplot>0){dev.off()}  # this line goes after you've finished plotting (to output the example below, move it to the bottom of the script)
if(outputplot==1){pdf("powercurves.pdf", bg="transparent", height = 5.5, width = 5.5)}
if(outputplot==2){postscript("powercurves.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)}
plotlims <- c(0,200,0,100)  # define the x and y limits of the plot (minx,maxx,miny,maxy)
ticklocsx <- seq(0,200,50)    # locations of tick marks on x axis
ticklocsy <- seq(0,100,20)    # locations of tick marks on y axis
ticklabelsx <- ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks
par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  # the 'line' command moves away from the axis, the 'las' command rotates to vertical
title(xlab="Sample size (N)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Power (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
lines(c(-10,210),c(80,80),lty=2)
ramp <- colorRamp(c("black","red"))  # create a ramp from one colour to another
colourvect <- rgb(ramp(seq(0, 1, length = 5)), max = 255)
dvect <- seq(0.2,1,0.2)
for (n in 1:length(dvect)){
output <- pwr.t.test(d=dvect[n],n=nsubjs,sig.level=alphalevel,type="one.sample",alternative='two.sided')
lines(nsubjs,100*output$power,col=colourvect[n],lwd=3)
}
legend(120, 40, c("d = 0.2","d = 0.4","d = 0.6","d = 0.8","d = 1"), cex=1, col=colourvect, lty=1, lwd=3, box.lwd=2)
if(outputplot>0){dev.off()}  # this line goes after you've finished plotting (to output the example below, move it to the bottom of the script)
groupmean <- 0.5
SDlist <- c(0,2,4,6,8,10)
interpSD <- 2
allSDests <- matrix(0,nrow=length(SDlist),ncol=length(nsamplevect))
powerlist <- matrix(0,nrow=length(SDlist),ncol=length(nsamplevect))
for (smp in 1:length(nsamplevect)){
for (thissd in 1:length(SDlist)){
sampleSD <- sqrt(interpSD^2 + (SDlist[thissd]^2)/nsamplevect[smp])
destimate <- groupmean/sampleSD
output <- pwr.t.test(d=destimate,n=max(nsubjs),sig.level=alphalevel,type="one.sample",alternative='two.sided')
powerlist[thissd,smp] <- output$power
allSDests[thissd,smp] <- sampleSD
}}
if(outputplot==1){pdf("SDs.pdf", bg="transparent", height = 5.5, width = 5.5)}
if(outputplot==2){postscript("SDs.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)}
plotlims <- c(0,100,0,8)  # define the x and y limits of the plot (minx,maxx,miny,maxy)
ticklocsx <- seq(0,100,25)    # locations of tick marks on x axis
ticklocsy <- seq(0,8,1)    # locations of tick marks on y axis
ticklabelsx <- ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks
par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  # the 'line' command moves away from the axis, the 'las' command rotates to vertical
title(xlab="Trials per participant (k)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab=expression(paste("Sample SD (",sigma[s],")")), col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
ramp <- colorRamp(c("black","green"))  # create a ramp from one colour to another
colourvect <- rgb(ramp(seq(0, 1, length = length(SDlist))), max = 255)
for (cond in 1:length(SDlist)){lines(nsamplevect,allSDests[cond,],col=colourvect[cond],lwd=3)}
legend(60,8, c(expression(paste(sigma[w], " = 0")),expression(paste(sigma[w], " = 2")),expression(paste(sigma[w], " = 4")),expression(paste(sigma[w], " = 6")),expression(paste(sigma[w], " = 8")),expression(paste(sigma[w], " = 10"))), cex=1, col=colourvect, lty=1, lwd=3, box.lwd=2)
if(outputplot>0){dev.off()}  # this line goes after you've finished plotting (to output the example below, move it to the bottom of the script)
if(outputplot==1){pdf("powervstrials.pdf", bg="transparent", height = 5.5, width = 5.5)}
if(outputplot==2){postscript("powervstrials.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)}
plotlims <- c(0,100,0,100)  # define the x and y limits of the plot (minx,maxx,miny,maxy)
ticklocsx <- seq(0,100,25)    # locations of tick marks on x axis
ticklocsy <- seq(0,100,20)    # locations of tick marks on y axis
ticklabelsx <- ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks
par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  # the 'line' command moves away from the axis, the 'las' command rotates to vertical
title(xlab="Trials per participant (k)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Power (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
for (cond in 1:length(SDlist)){lines(nsamplevect,100*powerlist[cond,],col=colourvect[cond],lwd=3)}
lines(c(-5,105),c(80,80),lty=2)
if(outputplot>0){dev.off()}  # this line goes after you've finished plotting (to output the example below, move it to the bottom of the script)
histSDs <- NULL
groupmean <- 0
nsubjs <- 50
interpSD <- 2
nsamples <- 2
intrapSD <- 0
datamatrix <- matrix(0,nrow=nsubjs,ncol=nsamples)
for (s in 1:nsubjs){datamatrix[s,] <- rnorm(nsamples,mean=rnorm(1,mean=groupmean,sd=interpSD),sd=intrapSD)}
subjmeans <- rowMeans(datamatrix)
subjSEs <- apply(datamatrix,1,sd)/sqrt(nsamples)
if(outputplot==1){pdf("hist1.pdf", bg="transparent", height = 5.5, width = 5.5)}
if(outputplot==2){postscript("hist1.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)}
plotlims <- c(-12,12,0,1.1)  # define the x and y limits of the plot (minx,maxx,miny,maxy)
ticklocsx <- seq(-12,12,4)    # locations of tick marks on x axis
ticklocsy <- (0:5)/5    # locations of tick marks on y axis
ticklabelsx <- ticklocsx        # set labels for x ticks
ticklabelsy <- c("0","0.2","0.4","0.6","0.8","1")    # set labels for y ticks
par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
xvals <- seq(-12,12,0.1)
sampleSD <- sqrt(interpSD^2 + (intrapSD^2)/nsamples)
gausfunc <- exp(-((xvals-0)^2)/(2*sampleSD^2))
for (s in 1:nsubjs){
ypos <- runif(1,min=0,max=0.95*exp(-((subjmeans[s])^2)/(2*sampleSD^2)))
points(subjmeans[s], ypos, pch = 16, col=rgb(0.4,0.4,0.8), cex=0.6, lwd=3)   # draw the data points themselves
}
lines(xvals, gausfunc, col=rgb(0.5,0.5,1),lty=1,lwd=5) # plot upside down hanging from the top axis with our transparent colour
lines(c(0,0),c(0,1), col='grey', lwd=3, cex=0.5, lty=1)     # draw a line connecting the points
if(outputplot>0){dev.off()}  # this line goes after you've finished plotting (to output the example below, move it to the bottom of the script)
nsamples <- 20
intrapSD <- 10
datamatrix <- matrix(0,nrow=nsubjs,ncol=nsamples)
for (s in 1:nsubjs){datamatrix[s,] <- rnorm(nsamples,mean=rnorm(1,mean=groupmean,sd=interpSD),sd=intrapSD)}
subjmeans <- rowMeans(datamatrix)
subjSEs <- apply(datamatrix,1,sd)/sqrt(nsamples)
if(outputplot==1){pdf("hist2.pdf", bg="transparent", height = 5.5, width = 5.5)}
if(outputplot==2){postscript("hist2.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)}
plotlims <- c(-12,12,0,1.1)  # define the x and y limits of the plot (minx,maxx,miny,maxy)
ticklocsx <- seq(-12,12,4)    # locations of tick marks on x axis
ticklocsy <- (0:5)/5    # locations of tick marks on y axis
ticklabelsx <- ticklocsx        # set labels for x ticks
ticklabelsy <- c("0","0.2","0.4","0.6","0.8","1")    # set labels for y ticks
par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
xvals <- seq(-12,12,0.1)
sampleSD <- sqrt(interpSD^2 + (intrapSD^2)/nsamples)
gausfunc <- exp(-((xvals-0)^2)/(2*sampleSD^2))
for (s in 1:nsubjs){
ypos <- runif(1,min=0,max=0.95*exp(-((subjmeans[s])^2)/(2*sampleSD^2)))
polygon(c(subjmeans[s]-subjSEs[s],subjmeans[s]+subjSEs[s],subjmeans[s]+subjSEs[s],subjmeans[s]-subjSEs[s]),c(ypos-0.005,ypos-0.005,ypos+0.005,ypos+0.005),col=rgb(1,1,1),border=NA)
points(subjmeans[s], ypos, pch = 16, col=rgb(1,0.5,0), cex=0.6, lwd=3)   # draw the data points themselves
}
lines(xvals, gausfunc, col=rgb(1,0.5,0),lty=1,lwd=5) # plot upside down hanging from the top axis with our transparent colour
lines(c(0,0),c(0,1), col='grey', lwd=3, cex=0.5, lty=1)     # draw a line connecting the points
if(outputplot>0){dev.off()}  # this line goes after you've finished plotting (to output the example below, move it to the bottom of the script)
nsamples <- 200
intrapSD <- 10
datamatrix <- matrix(0,nrow=nsubjs,ncol=nsamples)
for (s in 1:nsubjs){datamatrix[s,] <- rnorm(nsamples,mean=rnorm(1,mean=groupmean,sd=interpSD),sd=intrapSD)}
subjmeans <- rowMeans(datamatrix)
subjSEs <- apply(datamatrix,1,sd)/sqrt(nsamples)
if(outputplot==1){pdf("hist3.pdf", bg="transparent", height = 5.5, width = 5.5)}
if(outputplot==2){postscript("hist3.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)}
plotlims <- c(-12,12,0,1.1)  # define the x and y limits of the plot (minx,maxx,miny,maxy)
ticklocsx <- seq(-12,12,4)    # locations of tick marks on x axis
ticklocsy <- (0:5)/5    # locations of tick marks on y axis
ticklabelsx <- ticklocsx        # set labels for x ticks
ticklabelsy <- c("0","0.2","0.4","0.6","0.8","1")    # set labels for y ticks
par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
xvals <- seq(-12,12,0.1)
sampleSD <- sqrt(interpSD^2 + (intrapSD^2)/nsamples)
gausfunc <- exp(-((xvals-0)^2)/(2*sampleSD^2))
for (s in 1:nsubjs){
ypos <- runif(1,min=0,max=0.95*exp(-((subjmeans[s])^2)/(2*sampleSD^2)))
polygon(c(subjmeans[s]-subjSEs[s],subjmeans[s]+subjSEs[s],subjmeans[s]+subjSEs[s],subjmeans[s]-subjSEs[s]),c(ypos-0.005,ypos-0.005,ypos+0.005,ypos+0.005),col=rgb(1,1,1),border=NA)
points(subjmeans[s], ypos, pch = 16, col=rgb(1,0.5,0.5), cex=0.6, lwd=3)   # draw the data points themselves
}
lines(xvals, gausfunc, col=rgb(1,0.5,0.5),lty=1,lwd=5) # plot upside down hanging from the top axis with our transparent colour
lines(c(0,0),c(0,1), col='grey', lwd=3, cex=0.5, lty=1)     # draw a line connecting the points
if(outputplot>0){dev.off()}  # this line goes after you've finished plotting (to output the example below, move it to the bottom of the script)
# if we're outputting as postscript, it's because we're merging to create the full figure
if(outputplot==2){
library(grImport)
PostScriptTrace('hist1.ps')
e1 <- readPicture('hist1.ps.xml')
PostScriptTrace('hist2.ps')
e2 <- readPicture('hist2.ps.xml')
for (n in 1:length(e2@paths)){
temp <- class(e2@paths[n]$path)[1]
if (pmatch(temp,"PictureFill",nomatch=0)){
if (sum(col2rgb(e2@paths[n]$path@rgb))==765){e2@paths[n]$path@rgb <- rgb(1,0.5,0,alpha=0.3)}}}
PostScriptTrace('hist3.ps')
e3 <- readPicture('hist3.ps.xml')
for (n in 1:length(e3@paths)){
temp <- class(e3@paths[n]$path)[1]
if (pmatch(temp,"PictureFill",nomatch=0)){
if (sum(col2rgb(e3@paths[n]$path@rgb))==765){e3@paths[n]$path@rgb <- rgb(1,0.5,0.5,alpha=0.3)}}}
PostScriptTrace('powercurves.ps')
e4 <- readPicture('powercurves.ps.xml')
PostScriptTrace('SDS.ps')
e5 <- readPicture('SDS.ps.xml')
PostScriptTrace('powervstrials.ps')
e6 <- readPicture('powervstrials.ps.xml')
PostScriptTrace('Meancontour1.ps')
e7 <- readPicture('Meancontour1.ps.xml')
for (n in 1:length(e7@paths)){
temp <- class(e7@paths[n]$path)[1]
if (pmatch(temp,"PictureFill",nomatch=0)){
if (sum(col2rgb(e7@paths[n]$path@rgb))<765){e7@paths[n]$path@rgb <- addalpha(e7@paths[n]$path@rgb,alpha=0.2)}}}
PostScriptTrace('Meancontour2.ps')
e8 <- readPicture('Meancontour2.ps.xml')
for (n in 1:length(e8@paths)){
temp <- class(e8@paths[n]$path)[1]
if (pmatch(temp,"PictureFill",nomatch=0)){
e8@paths[n]$path@rgb <- addalpha(e8@paths[n]$path@rgb,alpha=0.2)}}
pdf("Figure1.pdf", bg="transparent", height = 18, width = 16.5)
par(mar=c(0.1,0.1,0.1,0.1))
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(0,1), ylim=c(0,1))   # create an empty axis of the correct dimensions
grid.picture(e1,x=0.2,y=0.85,width=0.3,height=1)
grid.picture(e2,x=0.5,y=0.85,width=0.3,height=1)
grid.picture(e3,x=0.8,y=0.85,width=0.3,height=1)
grid.picture(e4,x=0.2,y=0.56,width=0.3,height=1)
grid.picture(e5,x=0.5,y=0.56,width=0.3,height=1)
grid.picture(e6,x=0.8,y=0.56,width=0.3,height=1)
grid.picture(e7,x=0.25,y=0.2,width=0.45,height=1)
grid.picture(e8,x=0.75,y=0.2,width=0.45,height=1)
text(-0.01,1,'(a)',pos=4,cex=3)
text(0.32,1,'(b)',pos=4,cex=3)
text(0.64,1,'(c)',pos=4,cex=3)
text(-0.01,0.72,'(d)',pos=4,cex=3)
text(0.32,0.72,'(e)',pos=4,cex=3)
text(0.65,0.72,'(f)',pos=4,cex=3)
text(-0.01,0.4,'(g)',pos=4,cex=3)
text(0.5,0.4,'(h)',pos=4,cex=3)
text(0.02,0.97,expression(paste(sigma[w], " = 0")),pos=4,cex=2)
text(0.02,0.94,expression(paste(sigma[b], " = 2")),pos=4,cex=2)
text(0.02,0.91,expression(paste(sigma[s], " = 2")),pos=4,cex=2)
text(0.02,0.88,expression(paste("1:",infinity, " trials")),pos=4,cex=2)
text(0.35,0.97,expression(paste(sigma[w], " = 10")),pos=4,cex=2)
text(0.35,0.94,expression(paste(sigma[b], " = 2")),pos=4,cex=2)
text(0.35,0.91,expression(paste(sigma[s], " = 3")),pos=4,cex=2)
text(0.35,0.88,"20 trials",pos=4,cex=2)
text(0.67,0.97,expression(paste(sigma[w], " = 10")),pos=4,cex=2)
text(0.67,0.94,expression(paste(sigma[b], " = 2")),pos=4,cex=2)
text(0.67,0.91,expression(paste(sigma[s], " = 2.1")),pos=4,cex=2)
text(0.67,0.88,"200 trials",pos=4,cex=2)
text(0.18,0.39,expression(paste(sigma[w], " = 0, ", sigma[b], " = 2")),pos=4,cex=2)
text(0.72,0.39,expression(paste(sigma[w], " = 10, ", sigma[b], " = 2")),pos=4,cex=2)
text(0.41,0.68,expression(paste(sigma[b], " = 2")),pos=4,cex=2)
text(0.88,0.52,"M=0.5",pos=4,cex=2)
text(0.88,0.49,"N=200",pos=4,cex=2)
dev.off()
file.remove(c('hist1.ps','hist2.ps','hist3.ps','powercurves.ps','SDs.ps','Meancontour1.ps','Meancontour2.ps','powervstrials.ps'))
file.remove(c('capturehist1.ps','capturehist2.ps','capturehist3.ps','capturepowercurves.ps','captureSDs.ps','captureMeancontour1.ps','captureMeancontour2.ps','capturepowervstrials.ps'))
file.remove(c('hist1.ps.xml','hist2.ps.xml','hist3.ps.xml','powercurves.ps.xml','SDs.ps.xml','Meancontour1.ps.xml','Meancontour2.ps.xml','powervstrials.ps.xml'))
}
toc()
source("~/Downloads/powercontoursmean.R", echo=TRUE)
# if we're outputting as postscript, it's because we're merging to create the full figure
if(outputplot==2){
library(grImport)
PostScriptTrace('hist1.ps')
e1 <- readPicture('hist1.ps.xml')
PostScriptTrace('hist2.ps')
e2 <- readPicture('hist2.ps.xml')
for (n in 1:length(e2@paths)){
temp <- class(e2@paths[n]$path)[1]
if (pmatch(temp,"PictureFill",nomatch=0)){
if (sum(col2rgb(e2@paths[n]$path@rgb))==765){e2@paths[n]$path@rgb <- rgb(1,0.5,0,alpha=0.3)}}}
PostScriptTrace('hist3.ps')
e3 <- readPicture('hist3.ps.xml')
for (n in 1:length(e3@paths)){
temp <- class(e3@paths[n]$path)[1]
if (pmatch(temp,"PictureFill",nomatch=0)){
if (sum(col2rgb(e3@paths[n]$path@rgb))==765){e3@paths[n]$path@rgb <- rgb(1,0.5,0.5,alpha=0.3)}}}
PostScriptTrace('powercurves.ps')
e4 <- readPicture('powercurves.ps.xml')
PostScriptTrace('SDS.ps')
e5 <- readPicture('SDS.ps.xml')
PostScriptTrace('powervstrials.ps')
e6 <- readPicture('powervstrials.ps.xml')
PostScriptTrace('Meancontour1.ps')
e7 <- readPicture('Meancontour1.ps.xml')
for (n in 1:length(e7@paths)){
temp <- class(e7@paths[n]$path)[1]
if (pmatch(temp,"PictureFill",nomatch=0)){
if (sum(col2rgb(e7@paths[n]$path@rgb))<765){e7@paths[n]$path@rgb <- addalpha(e7@paths[n]$path@rgb,alpha=0.2)}}}
PostScriptTrace('Meancontour2.ps')
e8 <- readPicture('Meancontour2.ps.xml')
for (n in 1:length(e8@paths)){
temp <- class(e8@paths[n]$path)[1]
if (pmatch(temp,"PictureFill",nomatch=0)){
e8@paths[n]$path@rgb <- addalpha(e8@paths[n]$path@rgb,alpha=0.2)}}
pdf("Figure1.pdf", bg="transparent", height = 18, width = 16.5)
par(mar=c(0.1,0.1,0.1,0.1))
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(0,1), ylim=c(0,1))   # create an empty axis of the correct dimensions
grid.picture(e1,x=0.2,y=0.85,width=0.3,height=1)
grid.picture(e2,x=0.5,y=0.85,width=0.3,height=1)
grid.picture(e3,x=0.8,y=0.85,width=0.3,height=1)
grid.picture(e4,x=0.2,y=0.56,width=0.3,height=1)
grid.picture(e5,x=0.5,y=0.56,width=0.3,height=1)
grid.picture(e6,x=0.8,y=0.56,width=0.3,height=1)
grid.picture(e7,x=0.25,y=0.2,width=0.45,height=1)
grid.picture(e8,x=0.75,y=0.2,width=0.45,height=1)
text(-0.01,1,'(a)',pos=4,cex=3)
text(0.32,1,'(b)',pos=4,cex=3)
text(0.64,1,'(c)',pos=4,cex=3)
text(-0.01,0.72,'(d)',pos=4,cex=3)
text(0.32,0.72,'(e)',pos=4,cex=3)
text(0.65,0.72,'(f)',pos=4,cex=3)
text(-0.01,0.4,'(g)',pos=4,cex=3)
text(0.5,0.4,'(h)',pos=4,cex=3)
text(0.02,0.97,expression(paste(sigma[w], " = 0")),pos=4,cex=2)
text(0.02,0.94,expression(paste(sigma[b], " = 2")),pos=4,cex=2)
text(0.02,0.91,expression(paste(sigma[s], " = 2")),pos=4,cex=2)
text(0.02,0.88,expression(paste("1:",infinity, " trials")),pos=4,cex=2)
text(0.35,0.97,expression(paste(sigma[w], " = 10")),pos=4,cex=2)
text(0.35,0.94,expression(paste(sigma[b], " = 2")),pos=4,cex=2)
text(0.35,0.91,expression(paste(sigma[s], " = 3")),pos=4,cex=2)
text(0.35,0.88,"20 trials",pos=4,cex=2)
text(0.67,0.97,expression(paste(sigma[w], " = 10")),pos=4,cex=2)
text(0.67,0.94,expression(paste(sigma[b], " = 2")),pos=4,cex=2)
text(0.67,0.91,expression(paste(sigma[s], " = 2.1")),pos=4,cex=2)
text(0.67,0.88,"200 trials",pos=4,cex=2)
text(0.18,0.39,expression(paste(sigma[w], " = 0, ", sigma[b], " = 2")),pos=4,cex=2)
text(0.72,0.39,expression(paste(sigma[w], " = 10, ", sigma[b], " = 2")),pos=4,cex=2)
text(0.41,0.68,expression(paste(sigma[b], " = 2")),pos=4,cex=2)
text(0.88,0.52,"M=0.5",pos=4,cex=2)
text(0.88,0.49,"N=200",pos=4,cex=2)
dev.off()
file.remove(c('hist1.ps','hist2.ps','hist3.ps','powercurves.ps','SDs.ps','Meancontour1.ps','Meancontour2.ps','powervstrials.ps'))
file.remove(c('capturehist1.ps','capturehist2.ps','capturehist3.ps','capturepowercurves.ps','captureSDs.ps','captureMeancontour1.ps','captureMeancontour2.ps','capturepowervstrials.ps'))
file.remove(c('hist1.ps.xml','hist2.ps.xml','hist3.ps.xml','powercurves.ps.xml','SDs.ps.xml','Meancontour1.ps.xml','Meancontour2.ps.xml','powervstrials.ps.xml'))
}
